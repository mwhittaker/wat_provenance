\documentclass{mwhittaker}
\title{Wat-Provenance}
\author{~}
\date{~}

\usepackage{pervasives}
\usepackage{subcaption}
\usepackage{tikz}

\usetikzlibrary{shapes}
\usetikzlibrary{decorations.pathmorphing}
\usetikzlibrary{shapes.multipart}



\begin{document}
\maketitle

\section{Relational Algebra Provenance}
\begin{figure}[h]
  \begin{subfigure}[b]{0.5\textwidth}
    \centering
    \[
      \begin{array}{rrl}
        Q & ::= & \emptyset \\
          &   | & \set{t} \\
          &   | & R \\
          &   | & \select_\phi(Q) \\
          &   | & \project_A(Q) \\
          &   | & Q_1 \join Q_2 \\
          &   | & Q_1 \cup Q_2 \\
          &   | & \rename_{A \mapsto B}(Q)
      \end{array}
    \]
    \caption{Relational algebra syntax}
    \label{fig:ra-syntax}
  \end{subfigure}
  \begin{subfigure}[b]{0.5\textwidth}
    \centering
    \[
      \begin{aligned}
        \denote{\emptyset}(I) &= \emptyset \\
        \denote{\set{t}}(I) &= \set{t} \\
        \denote{R}(I) &= I(R) \\
        \denote{\select_\phi(Q)}(I) &= \setst{t \in \denote{Q}(I)}{\phi(t)} \\
        \denote{\project_A(Q)}(I) &= \setst{t[A]}{t \in \denote{Q}(I)} \\
        \denote{Q_1 \join Q_2}(I) &= \setst{t}{t[A_1] \in \denote{Q_1}(I) \land t[A_2] \in \denote{Q_2}(I)} \\
        \denote{Q_1 \cup Q_2}(I) &= \denote{Q_1}(I) \cup \denote{Q_2}(I) \\
        \denote{\rename_{A \mapsto B}(Q)}(I) &= \setst{t[A \mapsto B]}{t \in \denote{Q}(I)}
      \end{aligned}
    \]
    \caption{Relational algebra semantics}
    \label{fig:ra-semantics}
  \end{subfigure}
\end{figure}

\subsection{Lineage}
\begin{align*}
  \Lineage(\emptyset, I, t) &= \bot \\
  \Lineage(\set{t}, I, u) &= \begin{cases}
    \emptyset & t = u \\
    \bot & t \neq u
  \end{cases} \\
  \Lineage(R, I, t) &= \begin{cases}
    \set{t} & t \in I(R) \\
    \bot & t \notin I(R)
  \end{cases} \\
  \Lineage(\select_\phi(Q), I, t) &= \begin{cases}
    \Lineage(Q, I, t) & \phi(t) \\
    \bot & \lnot \phi(t)
  \end{cases} \\
  \Lineage(\project_A(Q), I, t) &= \bigcup_L \setst{\Lineage(Q, I, u)}{u \in \denote{Q}(I), u[A] = t} \\
  \Lineage(Q_1 \join Q_2, I, t) &= \Lineage(Q_1, I, t[A_1]) \cup_S \Lineage(Q_2, I, t[A_2]) \\
  \Lineage(Q_1 \cup Q_2, I, t) &= \Lineage(Q_1, I, t) \cup_L \Lineage(Q_2, I, t) \\
  \Lineage(\rename_{A \mapsto B}(Q), I, t) &= \Lineage(Q, I, t[B \mapsto A])
\end{align*}

\subsection{Why-Provenance}
\begin{align*}
  \Why(\emptyset, I, t) &= \emptyset \\
  \Why(\set{t}, I, u) &= \begin{cases}
    \set{\emptyset} & t = u \\
    \emptyset & t \neq u
  \end{cases} \\
  \Why(R, I, t) &= \begin{cases}
    \set{\set{t}} & t \in I(R) \\
    \emptyset & t \notin I(R) \\
  \end{cases} \\
  \Why(\select_\phi(Q), I, t) &= \begin{cases}
    \Why(Q, I, t) & \phi() \\
    \emptyset & \lnot \phi(t)
  \end{cases} \\
  \Why(\project_A(Q), I, t) &= \bigcup \setst{\Why(Q, I, u)}{u \in \denote{Q}(I), u[A] = t} \\
  \Why(Q_1 \join Q_2, I, t) &= \Why(Q_1, I, t[A_1]) \Cup \Why(Q_2, t, t[A_2]) \\
  \Why(Q_1 \cup Q_2, I, t) &= \Why(Q_1, I, t) \cup \Why(Q_2, I, t) \\
  \Why(\rename_{A \mapsto B}(Q), I, t) &= \Why(Q, I, t[B \mapsto A])
\end{align*}

Some definitions:
\begin{align*}
  \Wit(Q, I, t)
    &\defeq \setst{J \subseteq I}{t \in \denote{Q}(J)} \\
  \MWit(Q, I, t)
    &\defeq \setst{J \in \Wit(Q, I, t)}{\text{$J$ is minimal in $\Wit(Q, I, t)$}} \\
  \MWhy(Q, I, t)
    &\defeq \setst{J \in \Why(Q, I, t)}{\text{$J$ is minimal in $\Why(Q, I, t)$}}
\end{align*}

Some theorems:
\begin{align*}
  \Wit(Q, I, t)
    &= \setst{J \subseteq I}{\exists J' \in \Wit(Q, I, t).\ J' \subseteq J} \\
  \MWhy(Q, I, t)
    &= \MWit(Q, I, t)
\end{align*}

\subsection{How-Provenance}
A \textbf{commutative semiring} is an algebraic structure $(K, +, \cdot, 0, 1)$
where
\begin{itemize}
  \item $(K, +, 0)$ is a commutative monoid,
  \item $(K, \cdot, 1)$ is a commutative monoid,
  \item multiplication distributes over addition, and
  \item 0 is an annihilator under multiplication.
\end{itemize}

Given a commutative semigroup $K$, a $K$-relation $R$ is a function from a
domain of tuples to $K$. The $K$-relational algebra has the same syntax as the
relational algebra and has following semantics:
\begin{align*}
  \denote{\emptyset}(I)(t) &= 0 \\
  \denote{\set{t}}(I)(u) &= \begin{cases}
    1 & t = u \\
    0 & t \neq u
  \end{cases} \\
  \denote{R}(I)(t) &= I(R)(t) \\
  \denote{\select_\phi(Q)}(I)(t) &= \phi(t) \cdot \denote{Q}(I)(t) \\
  \denote{\project_A(Q)}(I)(t) &= \sum_{u, u[A] = t} \denote{Q}(I)(u)\\
  \denote{Q_1 \join Q_2}(I)(t) &= \denote{Q_1}(I)(t[A_1]) \cdot \denote{Q_2}(I)(t[A_2]) \\
  \denote{Q_1 \cup Q_2}(I)(t) &= \denote{Q_1}(I)(t) + \denote{Q_2}(I)(t) \\
  \denote{\rename_{A \mapsto B}(Q)}(I)(t) &= \denote{Q}(I)(t[B \mapsto A])
\end{align*}

Note that
\begin{itemize}
  \item
    the semiring $(\set{\bot, \top}, \lor, \land, \bot, \top)$ corresponds to
    relational algebra,
  \item
    the semiring $(\nats, +, \times, 0, 1)$ corresponds to bag algebra,
  \item
    the semiring $(2^{TupleId}_\bot, \cup_L, \cup_S, \bot, \emptyset)$
    corresponds to lineage,
  \item
    the semiring $(2^{2^{TupleId}}, \cup, \Cup, \emptyset, \set{\emptyset})$
    corresponds to why-provenance, and
  \item
    the semiring $(\nats[TupleId], +, \times, 0, 1)$ corresponds to
    how-provenance.
\end{itemize}

Given an assignment $v: TupleId \to K$ from tuple ids to elements of another
semiring $K$, evaluating the how-provenance polynomial for a query $Q$ (after
substituting $v(x)$ for $x$) simulates evaluating $Q$ under $K$. For example,
given a how-provenance polynomial, we can use $v(x) = \top$ for relational
algebra, $v(x) = 1$ for bag algebra, $v(x) = \set{x}$ for lineage, and $v(x) =
\set{\set{x}}$ for why-provenance.

\section{Datalog Provenance}
- Provenance graphs for monotone datalog.
- Translating provenance graphs to how-provenance, why-provenance, and lineage.
- Extending provenance and provenance graphs to datalog with negation and
  aggregation.

page 89
``
Both lineage and Trio lineage have been defined for non-monotone operations
such as aggregation and negation operations. However, it is non-obvious how to
extend these definitions to why- or how-provenance while preserving their nice
properties
''

\section{Dedalus Provenance}
\begin{verbatim}
  # EDB to IDB
  r1: kvs_pos(K, V)                   :- kvs(K, V)
  r2: set_req_pos(DST, SRC, ID, K, V) :- set_req(DST, SRC, ID, K, V)
  r3: set_resp_pos(DST, ID)           :- set_resp(DST, ID)
  r4: get_req_pos(DST, SRC, ID, K)    :- get_req(DST, SRC, ID, K)
  r5: get_resp_pos(DST, ID, V)        :- get_resp(DST, ID, V)

  # Persist KVS
  r6: kvs_pos(K, V)@next :- kvs_pos(K, V), !kvs_neg(K, V)

  # Rules
  r7:  get_resp_pos(SRC, ID, V)@async :- kvs_pos(K, V), get_req_pos(_, SRC, ID, K)
  r8:  kvs_neg(K, V)                  :- kvs_pos(K, V), set_req_pos(_, _, _, K, _)
  r9:  kvs_pos(K, V)@next             :- set_req_pos(_, _, _, K, V)
  r10: set_resp_pos(SRC, ID)@async    :- set_req_pos(_, SRC, ID, _, _)
\end{verbatim}

\begin{verbatim}
  # EDB
  set_req(s, c, 0, x, y)@0
  get_req(s, c, 1, x)@1
\end{verbatim}

\tikzstyle{common}=[draw]
\tikzstyle{t}=[common,rectangle split, rectangle split parts=2,align=center]
\tikzstyle{neg}=[fill=red!20]
\tikzstyle{r}=[common, ellipse]
\tikzstyle{label}=[inner sep=0, circle, fill=white]

\begin{figure}[h]
  \centering
  \footnotesize
  \begin{tikzpicture}[xscale=2.5, yscale=1.5]
    \node[t] (t1) at (0, 10) {
      \texttt{set\_req@0}
      \nodepart{second}
      \texttt{(s,c,0,x,y)}
    };
    \node[label] (t1label) at (t1.north west) {$t_1$};

    \node[t] (t2) at (2, 10) {
      \texttt{set\_req\_pos@0}
      \nodepart{second}
      \texttt{(s,c,0,x,y)}
    };
    \node[label] (t2label) at (t2.north west) {$t_2$};

    \node[t] (t3) at (0, 9) {
      \texttt{set\_resp\_pos@async}
      \nodepart{second}
      \texttt{(c,0)}
    };
    \node[label] (t3label) at (t3.north west) {$t_3$};

    \node[r] () at (1, 10) {\texttt{r2}};
    \node[r] () at (1, 9) {\texttt{r10}};
    \node[r] () at (3, 10) {\texttt{r9}};

    \draw[decorate, decoration=snake] (-1, 8.5) -- (5, 8.5);

    \node[t] () at (3, 8) {
      \texttt{kvs\_pos@1}
      \nodepart{second}
      \texttt{(x,y)}
    };
    \node[t] () at (0, 8) {
      \texttt{get\_req@1}
      \nodepart{second}
      \texttt{(s,c,0,x)}
    };
    \node[r] () at (1, 8) {\texttt{r4}};
    \node[t] () at (2, 8) {
      \texttt{get\_req\_pos@1}
      \nodepart{second}
      \texttt{(s,c,0,x)@0}
    };
    \node[r] () at (1, 7) {\texttt{r7}};
    \node[t] () at (0, 7) {
      \texttt{get\_req\_resp@async}
      \nodepart{second}
      \texttt{(s,i,x,y)}
    };
    \node[t, neg] () at (4, 8) {
      \texttt{kvs\_neg@1}
      \nodepart{second}
      \texttt{(x,y)}
    };
    \node[r] () at (3, 7) {\texttt{r6}};

    \draw[decorate, decoration=snake] (-1, 6.5) -- (5, 6.5);

    \node[t] () at (3, 6) {
      \texttt{kvs\_pos@2}
      \nodepart{second}
      \texttt{(x,y)}
    };
  \end{tikzpicture}
  \caption{}
  \label{}
\end{figure}

\begin{verbatim}
  # EDB
  set_req(s, c, 0, x, y)@0
  set_req(s, c, 0, x, z)@1
  get_req(s, c, 1, x)@2
\end{verbatim}

- Provenance for Dedalus programs. EDB represents network requests.

\section{Network Provenance}
- Network provenance ala Boon.

\section{Wat-Provenance}
- Our new form of provenance.

\end{document}
